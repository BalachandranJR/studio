
{
  "name": "TripAssist Itinerary Generator (Direct Fetch)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "travel-planner",
        "responseMode": "lastNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "1a4465a8-c56a-4ca5-be29-e9038bcae8ef",
      "name": "Webhook Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -600,
        0
      ],
      "webhookId": "be0bc3ae-fdb8-47a8-8dc4-3af494e6aeac"
    },
    {
      "parameters": {
        "jsCode": "const payload = items[0].json;\n\n// Determine the actual data location\nlet actualData = payload.body || payload.query || payload.params || payload;\n\n// --- Helper Functions ---\n// A robust function to parse a date and ignore time/timezone.\nfunction parseDateAsUTC(dateString) {\n  if (!dateString) return null;\n  const date = new Date(dateString);\n  // Create a new date using only the year, month, and day from the original date in UTC.\n  // This effectively strips the time and timezone information.\n  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n}\n\nfunction objectToArray(obj) {\n  if (!obj || typeof obj !== 'object') return [];\n  return Object.values(obj).filter(Boolean);\n}\n\n// --- Validation and Processing ---\n\nif (!actualData.destination || !actualData.dates || !actualData.dates.from || !actualData.dates.to) {\n  return [{ json: { error: 'Missing required fields (destination or dates)' } }];\n}\n\n// Parse dates correctly, treating them as calendar dates without timezones.\nconst fromDate = parseDateAsUTC(actualData.dates.from);\nconst toDate = parseDateAsUTC(actualData.dates.to);\n\nif (!fromDate || !toDate || isNaN(fromDate.getTime()) || isNaN(toDate.getTime())) {\n    return [{ json: { error: 'Invalid date format provided' } }];\n}\n\n// Calculate the duration correctly (difference in days). Add 1 to be inclusive.\nconst duration = Math.round((toDate.getTime() - fromDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;\n\nif (duration <= 0) {\n  return [{ json: { error: 'Invalid date range provided. \"To\" date must be after \"From\" date.' } }];\n}\n\n// Format the date back to a simple YYYY-MM-DD string.\nconst fromDateString = fromDate.toISOString().split('T')[0];\nconst toDateString = toDate.toISOString().split('T')[0];\n\n\n// --- Final Processed Data ---\n\nconst processedData = {\n  destination: actualData.destination.trim(),\n  fromDate: fromDateString,\n  toDate: toDateString,\n  duration,\n  people: parseInt(actualData.numPeople, 10) || 1,\n  ageGroups: objectToArray(actualData.ageGroups),\n  interests: objectToArray(actualData.interests),\n  transport: objectToArray(actualData.transport),\n  foodPreferences: objectToArray(actualData.foodPreferences),\n  currency: actualData.budget?.currency || 'USD',\n  budgetAmount: parseFloat(actualData.budget?.amount) || 1000,\n};\n\nreturn [{ json: processedData }];"
      },
      "id": "8fc69740-8b51-4bc1-9c91-b63055d0dd9a",
      "name": "1. Process Input Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const input = items[0].json;\n\nif (input.error) {\n  // Pass the error through to be handled by the final node\n  return [{ json: { error: input.error, details: input.details || '' } }];\n}\n\nconst includeNightlife = input.interests && input.interests.includes('nightlife');\n\nconst prompt = `\nYou are a professional travel itinerary planning assistant.\nYour single task is to create a detailed, personalized itinerary in **strict, valid JSON format** based on the following user inputs. Your response MUST ONLY be the JSON object, with no other text, comments, or markdown.\n\n**User Preferences:**\n- Destination: ${input.destination}\n- Travel Dates: ${input.fromDate} to ${input.toDate}\n- Group Size: ${input.people} people\n- Age Groups: ${input.ageGroups.join(', ')}\n- Interests: ${input.interests.join(', ')}\n- Transport: ${input.transport.join(', ')}\n- Food Preferences: ${input.foodPreferences.length > 0 ? input.foodPreferences.join(', ') : 'None specified'}\n- Budget: ${input.budgetAmount} ${input.currency}\n\n**CRITICAL INSTRUCTIONS:**\n1.  **JSON ONLY:** Your entire response must be a single, valid JSON object. Do not wrap it in markdown (e.g., \\\`\\\`\\\`json).\n2.  **COMPLETE COVERAGE:** The itinerary must cover every day from ${input.fromDate} to ${input.toDate} inclusive.\n3.  **NO GAPS:** Every day must have planned activities. If a day is meant for rest or travel, create an activity entry explaining this (e.g., name: 'Arrival & Relaxation', description: 'Settle into the hotel and recover from the flight.').\n4.  **COSTS:** Use realistic costs in ${input.currency}.\n5.  **BE SPECIFIC:** Provide specific names for restaurants, attractions, and locations.\n\n**Required JSON Output Structure:**\n{\n  \"destination\": \"${input.destination}\",\n  \"startDate\": \"${input.fromDate}\",\n  \"endDate\": \"${input.toDate}\",\n  \"accommodation\": {\n    \"name\": \"<Specific hotel/accommodation name>\",\n    \"type\": \"<Hotel/Resort/Hostel/Airbnb>\",\n    \"location\": \"<Specific area/district>\",\n    \"costPerNight\": <number>,\n    \"totalCost\": <number>,\n    \"amenities\": [\"WiFi\", \"Pool\", \"Breakfast\", \"etc\"]\n  },\n  \"days\": [\n    {\n      \"day\": 1,\n      \"date\": \"YYYY-MM-DD\",\n      \"breakdown\": {\n          \"breakfast\": { \"time\": \"HH:MM\", \"name\": \"<Meal name>\", \"description\": \"...\", \"type\":\"food\", \"icon\":\"food\" },\n          \"lunch\": { \"time\": \"HH:MM\", \"name\": \"<Meal name>\", \"description\": \"...\", \"type\":\"food\", \"icon\":\"food\" },\n          \"dinner\": { \"time\": \"HH:MM\", \"name\": \"<Meal name>\", \"description\": \"...\", \"type\":\"food\", \"icon\":\"food\" },\n          \"morningActivities\": [ { \"time\": \"HH:MM\", \"name\": \"<Activity name>\", \"description\": \"...\", \"type\":\"activity\", \"icon\":\"default\" } ],\n          \"afternoonActivities\": [ { \"time\": \"HH:MM\", \"name\": \"<Activity name>\", \"description\": \"...\", \"type\":\"activity\", \"icon\":\"default\" } ],\n          \"nightlifeActivities\": [ { \"time\": \"HH:MM\", \"name\": \"<Activity name>\", \"description\": \"...\", \"type\":\"nightlife\", \"icon\":\"nightlife\" } ]\n      }\n    }\n  ],\n  \"costBreakdown\": {\n    \"accommodation\": <number>,\n    \"transport\": <number>,\n    \"meals\": <number>,\n    \"activities\": <number>,\n    \"nightlife\": <number>,\n    \"total\": <number>,\n    \"notes\": \"<Budget-saving tips and important notes>\"\n  }\n}\n`;\n\nreturn [{ json: { chatInput: prompt.trim() } }];"
      },
      "id": "c4b7177f-d4b2-48cc-8750-968141e2cda1",
      "name": "2. Format AI Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -200,
        0
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "You are a professional travel planning assistant. Always respond with valid JSON format as requested. Be specific with costs, locations, and practical travel advice. Do not include any text outside the JSON. Strictly follow the JSON schema provided."
        }
      },
      "id": "a8c173c6-fb57-4dcd-a402-e5a34c4219ad",
      "name": "3. AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        0,
        0
      ]
    },
     {
      "parameters": {
        "model": "google/gemini-pro",
        "options": {}
      },
      "id": "742ae1ab-7f89-471c-8e5b-80d1df61b349",
      "name": "Google AI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.chatGoogleGenerativeAi",
      "typeVersion": 1,
      "position": [
        0,
        200
      ],
      "credentials": {
        "googleApi": {
          "id": "YOUR_GOOGLE_API_CREDENTIAL_ID",
          "name": "Google AI Credentials"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const aiResponse = items[0].json;\n\n// Handle potential errors from the AI Agent node\nif (aiResponse.error || (aiResponse.chatInput && aiResponse.chatInput.startsWith('Error:'))) {\n  return [{ json: { error: 'Error during AI prompt generation.', details: aiResponse.error || aiResponse.chatInput } }];\n}\n\nlet responseText = null;\nif (typeof aiResponse === 'string') {\n  responseText = aiResponse;\n} else if (aiResponse.output && typeof aiResponse.output === 'string') {\n  responseText = aiResponse.output;\n} else if (aiResponse.text && typeof aiResponse.text === 'string') {\n  responseText = aiResponse.text;\n} else if (typeof aiResponse === 'object' && Object.keys(aiResponse).length > 0) {\n  // If the AI returns a JSON object directly, stringify it to handle it consistently.\n  try {\n    responseText = JSON.stringify(aiResponse);\n  } catch (e) { \n    return [{ json: { error: 'AI returned a non-stringifiable object.', details: e.message, rawResponse: aiResponse } }];\n   }\n} else {\n    return [{ json: { error: 'No valid AI response found in expected fields (output, text, or direct object).', rawResponse: aiResponse } }];\n}\n\n// Clean the response text: remove markdown formatting and trim whitespace.\nconst cleanedText = responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n\nlet itinerary;\ntry {\n  // Attempt to parse the cleaned text as JSON.\n  itinerary = JSON.parse(cleanedText);\n} catch (err) {\n  return [{ json: { error: 'Failed to parse AI response as JSON.', details: err.message, rawResponse: cleanedText } }];\n}\n\n// Validate the basic structure of the parsed itinerary.\nif (!itinerary || typeof itinerary !== 'object' || !itinerary.destination || !Array.isArray(itinerary.days)) {\n  return [{ json: { error: 'Invalid itinerary structure from AI.', details: 'Parsed JSON is missing destination or days array.', itinerary: itinerary } }];\n}\n\n// If everything is successful, return the parsed itinerary.\nreturn [{ json: { itinerary: itinerary } }];"
      },
      "id": "d3af5d3a-d506-4513-b15f-27c41f2c14cc",
      "name": "4. Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const input = items[0].json;\n\n// Pass through any errors from previous steps.\nif (input.error) {\n  return [{ json: { error: true, message: input.details || input.error } }];\n}\n\n// The parsed itinerary should be directly under the 'itinerary' key.\nconst itinerary = input.itinerary;\n\nif (!itinerary) {\n    return [{ json: { error: true, message: 'Itinerary object not found after parsing.' } }];\n}\n\n// Add a unique ID to the itinerary for tracking.\n itinerary.id = 'trip-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n\n// Return the final, validated itinerary object.\n// This will be the direct response of the webhook.\nreturn [{ json: { itinerary: itinerary } }];"
      },
      "id": "d2ce8a69-0644-4580-b66a-61d101f2c240",
      "name": "5. Format Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        0
      ]
    }
  ],
  "connections": {
    "Webhook Input": {
      "main": [
        [
          {
            "node": "1. Process Input Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "1. Process Input Data": {
      "main": [
        [
          {
            "node": "2. Format AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Format AI Prompt": {
      "main": [
        [
          {
            "node": "3. AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "3. AI Agent": {
      "main": [
        [
          {
            "node": "4. Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google AI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "3. AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "4. Parse AI Response": {
      "main": [
        [
          {
            "node": "5. Format Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "triggerCount": 0,
  "versionId": "f1a1b1c1-1b1b-1b1b-1b1b-1b1b1b1b1b1b"
}

    